/*Вам нужно написать реализацию функции 
void merge(ArrayList<Integer> a, ArrayList<Integer> b) { // тело функции } 

Функция принимает два отсортированных от меньшего к большему ArrayList одинакового размера [a1, a2, ..., an], [b1, b2, ..., bn]. В результате выполнения функции в первом(!) ArrayList (в данном случае это А) должны содержаться элементы обоих ArrayList, также отсортированные от меньшего к большему. Второй ArrayList должен остаться неизменненным.
ai ≤ ai+1
bi ≤ bi+1
-231 ≤ ai, bi ≤231-1

Пример:
Входные данные
A [1,3,5]
B [2,6,8]
Результат
A [1,2,3,5,6,8]
B [2,6,8]


Оцениваться будут следующие параметры:

- код должен работать корректно
- выполнять полезную функцию
- иметь максимально возможную эффективность - O(N) (задумайтесь, пожалуйста, над тем насколько эффективно написанная вами функция будет использовать память и процессорное время)
- не должен использовать Collections.sort()*/

static void merge(ArrayList<Integer> A, ArrayList<Integer> B) {
       
    ArrayList<Integer> mergedArr = new ArrayList<>(A.size() + B.size());/*
создаем   ArrayList  емкостью равной количеству элементов в исходных списках */
   
    int ai = 0, bi = 0;
    while (ai < A.size() && bi < B.size()) {//пока не перенесутся все элементы из-какого либо списка
        if (A.get(ai) < B.get(bi))
            mergedArr.add(A.get(ai++));
        else
            mergedArr.add(B.get(bi++));  /* сравниваем первые элементы списков и вставляем в новый список меньший из элементов. 
        Увличиваем индекс списка,элемент которого был выбран в итерации*/
    }
    while (ai < A.size())/*Смотрим,в каком списке остались элементы,
        добавляем их в отсортированный список*/
        mergedArr.add(A.get(ai++));
    while (bi < B.size())
       mergedArr.add(B.get(bi++));
     A.clear();//очищаем исходный список A
        A.addAll(mergedArr);// write the sorted collection to it
 
    
} 
